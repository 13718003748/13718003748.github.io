<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一款拖放排序插件</title>
      <link href="/2019/05/08/sortable/"/>
      <url>/2019/05/08/sortable/</url>
      
        <content type="html"><![CDATA[<p>最近遇到需求，需要在移动端中实现拖拽调度功能，能够在自己队列中拖动排序，也能够实现跨不同队列进行排序调度；因为时间紧，所以查阅资料找到一款轻量级的拖放排序插件，记录一下，以便后续参考！</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Sortable.js是一款轻量级的拖放排序列表的js插件（虽然体积小，但是功能很强大），同时也支持移动端，有react、VUE、angular版本。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>支持触屏设备和大部分浏览器（IE9以下的就不支持了，原因都懂得）</li><li>可以从一个列表容器中拖拽一个列表单元到其他容器或本列表容器中进行排序</li><li>移动列表单元时有css动画</li><li>支持拖放操作和可选择的文本（这句我也没理解，大概意思就是对原生的拖放进行拓展了）<a id="more"></a></li><li>非常友善的滚动效果</li><li>基于原生HTML5中的拖放API</li><li>支持多种框架（angular、vue、react等）</li><li>支持所有的css框架，像Bootstrap</li><li>简单的API，方便使用</li><li>CDN</li><li>不依赖jQuery</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre class=" language-JS"><code class="language-JS"><script src="../js/sortable.min.js?v=0.0"></script>var el = document.getElementById('items');new Sortable(el);//常用new Sortable(el, {       handle: ".my-handle", // 拖拽区域，默认为 items 的 子元素    onStart: function (/**Event*/evt) { // 拖拽开始        var itemEl = evt.item;// 当前拖拽的html元素    },    onEnd: function (/**Event*/evt) { // 拖拽结束        var itemEl = evt.item;    }    });</code></pre><h4 id="react版本"><a href="#react版本" class="headerlink" title="react版本"></a>react版本</h4><pre class=" language-JS"><code class="language-JS">import React from 'react';import ReactDOM from 'react-dom';import SharedGroup from './shared-group';const App = (props) => {    return (        <div>            <SharedGroup                items={['Apple', 'Banaba', 'Cherry', 'Grape']}            />            <br/>            <SharedGroup                items={['Lemon', 'Orange', 'Pear', 'Peach']}            />        </div>    );};ReactDOM.render(<App />, document.getElementById('container'));</code></pre><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><ul><li><p>group：string or array</p></li><li><p>sort：boolean 定义是否列表单元是否可以在列表容器内进行拖拽排序；</p></li><li><p>delay：number 定义鼠标选中列表单元可以开始拖动的延迟时间；</p></li><li><p>disabled：boolean 定义是否此sortable对象是否可用，为true时sortable对象不能拖放排序等功能，为false时为可以进行排序，相当于一个开关；</p></li><li><p>animation：number 单位：ms，定义排序动画的时间；</p></li><li><p>handle：selector 格式为简单css选择器的字符串，使列表单元中符合选择器的元素成为拖动的手柄，只有按住拖动手柄才能使列表单元进行拖动；</p></li><li><p>filter：selector 格式为简单css选择器的字符串，定义哪些列表单元不能进行拖放，可设置为多个选择器，中间用“，”分隔；</p></li><li><p>draggable：selector 格式为简单css选择器的字符串，定义哪些列表单元可以进行拖放</p></li><li><p>ghostClass：selector 格式为简单css选择器的字符串，当拖动列表单元时会生成一个副本作为影子单元来模拟被拖动单元排序的情况，此配置项就是来给这个影子单元添加一个class，我们可以通过这种方式来给影子元素进行编辑样式；</p></li><li><p>chosenClass：selector 格式为简单css选择器的字符串，当选中列表单元时会给该单元增加一个class；</p></li><li><p>forceFallback：boolean 如果设置为true时，将不使用原生的html5的拖放，可以修改一些拖放中元素的样式等；</p></li><li><p>fallbackClass：string 当forceFallback设置为true时，拖放过程中鼠标附着单元的样式；</p></li><li><p>scroll：boolean 默认为true，当排序的容器是个可滚动的区域，拖放可以引起区域滚动</p><h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3></li><li><p>onChoose：function 列表单元被选中的回调函数</p></li><li><p>onStart：function 列表单元拖动开始的回调函数</p></li><li><p>onEnd：function 列表单元拖放结束后的回调函数</p></li><li><p>onAdd：function 列表单元添加到本列表容器的回调函数</p></li><li><p>onUpdate：function 列表单元在列表容器中的排序发生变化后的回调函数</p></li><li><p>onRemove：function 列表元素移到另一个列表容器的回调函数</p></li><li><p>onFilter：function 试图选中一个被filter过滤的列表单元的回调函数</p></li><li><p>onMove：function 当移动列表单元在一个列表容器中或者多个列表容器中的回调函数</p></li><li><p>onClone：function 当创建一个列表单元副本的时候的回调函数</p><h3 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h3></li><li><p>事件对象在各个函数中略有不同，可通过输出对象查看对象的属性，下面简单列举几个：</p></li><li><p>to：HTMLElement–移动到列表容器</p></li><li><p>from：HTMLElement–来源的列表容器</p></li><li><p>item：HTMLElement–被移动的列表单元</p></li><li><p>clone：HTMLElement–副本的列表单元</p></li><li><p>oldIndex：number/undefined–在列表容器中的原序号</p></li><li><p>newIndex：number/undefined–在列表容器中的新序号</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>option(name[,value])<br>获得或者设置项参数，使用方法类似于jQuery用法，没有第二个参数为获得option中第一个参数所对应的值，有第二个参数时，将重新赋给第一个参数所对应的值；</p></li><li><p>closest</p></li><li><p>toArray()<br>序列化可排序的列表单元的data-id（可通过配置项中dataIdAttr修改）放入一个数组，并返回这个数组中</p></li><li><p>sort()<br>通过自定义列表单元的data-id的数组对列表单元进行排序</p></li><li><p>save()</p></li><li><p>destroy()</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript sortable.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动模拟promise</title>
      <link href="/2019/04/16/promise/"/>
      <url>/2019/04/16/promise/</url>
      
        <content type="html"><![CDATA[<p>日常工作中，经常会遇到需要异步执行的情况，es6之前我们经常处理方法是使用回调来处理，但是使用回调如果层级太多，逻辑会比较复杂，代码比较乱，不方便后期的维护，因此我们使用promise来处理异步执行情况，使用链式操作，使得代码逻辑清晰，易于维护。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><ul><li>pending/fulfilled(resolved)/reject;</li><li>当处于pending状态的时候，可以转移到fulfilled(resolved)或者rejected;</li><li>当处于fulfilled(resolved)状态或者rejected状态的时候，就不可改变。</li></ul><a id="more"></a><h3 id="promise的用法"><a href="#promise的用法" class="headerlink" title="promise的用法"></a>promise的用法</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">promise</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>操作成功<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//sucess</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//failure</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="模拟promise"><a href="#模拟promise" class="headerlink" title="模拟promise"></a>模拟promise</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myPromise</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    me<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'pending'</span> <span class="token comment" spellcheck="true">//定义状态改变前的初始状态</span>    me<span class="token punctuation">.</span>value <span class="token operator">=</span> undefined<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义状态为resolved的时候的状态</span>    me<span class="token punctuation">.</span>reason <span class="token operator">=</span> undefined<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义状态为reject的时候的状态</span>    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>me<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            me<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            me<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>me<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            me<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>            me<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'reject'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//捕获构造函数</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">constructor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>同时，还需要在myPromise的原型上定义链式调用的then方法</p><pre class=" language-js"><code class="language-js">myPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onfullfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>me<span class="token punctuation">.</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'resolved'</span><span class="token punctuation">:</span>            <span class="token function">onfullfilled</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'rejected'</span><span class="token punctuation">:</span>            <span class="token function">onRejected</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试一下:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre class=" language-bash"><code class="language-bash">1   /输出1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写call、apply、bind实现</title>
      <link href="/2019/04/11/changethis/"/>
      <url>/2019/04/11/changethis/</url>
      
        <content type="html"><![CDATA[<p>今天看到一道在寒冬季的大厂面试题，手动实现call、apply、bind,对其产生极大的兴趣，之前并没有想过其中的原理，只是在工作中直接使用，只了解能够改变this指向，但具体如何改变的并不了解，今天刚好看到，记录一下是如何实现的。<br>了解不够深入，有误的地方希望指出。</p><h3 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h3><ul><li>call<br>call接收多个参数，第一个为函数上下文，也就是this，后面参数为函数自身参数。<a id="more"></a></li><li>apply<br>apply接收两个参数，第一个参数为函数上下文this，第二个参数为函数参数，但是是通过数组的形式传入。</li><li>bind<br>bind接收多个参数，第一个是bind返回值是一个函数上下文的this，不会立即执行。</li></ul><h3 id="call、apply、bind的使用"><a href="#call、apply、bind的使用" class="headerlink" title="call、apply、bind的使用"></a>call、apply、bind的使用</h3><ul><li>call</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'一个'</span><span class="token punctuation">}</span><span class="token keyword">function</span> allName <span class="token punctuation">(</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`我的全名是“</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//明显此时allName函数是没有name属性的</span><span class="token punctuation">}</span><span class="token function">allName</span><span class="token punctuation">(</span><span class="token string">'我是'</span><span class="token punctuation">,</span><span class="token string">'前端'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//我的全名是“我是前端”  this指向window</span>allName<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'我是'</span><span class="token punctuation">,</span> <span class="token string">'前端'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//我的全名是“我是一个前端” this指向obj</span></code></pre><ul><li>apply</li></ul><pre class=" language-js"><code class="language-js">allName<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'我是'</span><span class="token punctuation">,</span> <span class="token string">'前端'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//我的全名是“我是一个前端” this指向obj</span></code></pre><ul><li>bind</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"一个"</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">allName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`我的全名是"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"我的座右铭是"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>flag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span>allName<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不会执行</span><span class="token keyword">let</span> fn <span class="token operator">=</span> allName<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">'我是'</span><span class="token punctuation">,</span> <span class="token string">'前端'</span><span class="token punctuation">,</span> <span class="token string">'好好学习天天向上'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 也可以这样用，参数可以分开传。bind后的函数参数默认排列在原函数参数后边</span>fn <span class="token operator">=</span> allName<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"你是"</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">'前端'</span><span class="token punctuation">,</span> <span class="token string">'好好学习天天向上'</span><span class="token punctuation">)</span></code></pre><h3 id="手动实现call、apply、bind"><a href="#手动实现call、apply、bind" class="headerlink" title="手动实现call、apply、bind"></a>手动实现call、apply、bind</h3><ul><li>call<br> 实现call需要考虑:<br> (1) call支持多个参数，有可能一个也不没有、考虑多参数时要把参数传给扩展方法;<br> (2) 考虑多参数时要把参数传给扩展方法;<br> (3) 给上下文定义的函数要保持唯一;<br> (4) 扩展完我们需要吧自定义函数删除;</li></ul><pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果没有传或传的值为空对象 context指向window</span>    context <span class="token operator">=</span> context <span class="token operator">||</span> window    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment" spellcheck="true">//给context添加一个方法 指向this</span>    <span class="token comment" spellcheck="true">// 处理参数 去除第一个参数this 其它传入fn函数</span>    <span class="token keyword">let</span> arg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组</span>    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//执行fn</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn <span class="token comment" spellcheck="true">//删除方法</span><span class="token punctuation">}</span><span class="token keyword">let</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>    <span class="token function">say</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`我叫</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">我今年</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Person1 <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Tom1'</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>say<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Person1<span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//我叫Tom1我今年18</span></code></pre><ul><li>apply<br>  apply注意第二个参数是数组，方法与call类似</li></ul><pre class=" language-js"><code class="language-js">    Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果没有传或传的值为空对象 context指向window</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> context <span class="token operator">===</span> <span class="token string">"undefined"</span> <span class="token operator">||</span> context <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context <span class="token operator">=</span> window    <span class="token punctuation">}</span>    <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment" spellcheck="true">//给context添加一个方法 指向this</span>        <span class="token comment" spellcheck="true">// 处理参数 去除第一个参数this 其它传入fn函数</span>    <span class="token keyword">let</span> arg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组</span>    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//执行fn</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn <span class="token comment" spellcheck="true">//删除方法</span>    <span class="token punctuation">}</span></code></pre><ul><li>bind<br>bind和call以及apply有所区别，bind主要有以下特点：<br>(1) 函数调用，改变this；<br>(2) 返回一个绑定this的函数;<br>(3) 接收多个参数;<br>(4) 支持柯里化形式传参 fn(1)(2)。</li></ul><pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回一个绑定this的函数，我们需要在此保存this</span>    <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment" spellcheck="true">// 可以支持柯里化传参，保存参数</span>    <span class="token keyword">let</span> arg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 返回一个函数</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//同样因为支持柯里化形式传参我们需要再次获取存储参数</span>        <span class="token keyword">let</span> newArg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArg<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 返回函数绑定this，传入两次保存的参数</span>            <span class="token comment" spellcheck="true">//考虑返回函数有返回值做了return</span>        <span class="token keyword">return</span> me<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>newArg<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token keyword">let</span> fn <span class="token operator">=</span> Person<span class="token punctuation">.</span>say<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>Person1<span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span></code></pre><p>此文章参考各前端大牛分享，总结出来，在此感谢大佬的分享！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2019/04/09/markdown/"/>
      <url>/2019/04/09/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>第一次搭建博客，为了记录自己工作中遇到的技术问题，人有的时候是懒惰的，学的技术点记不住，一段时间再次看，依然觉得陌生，甚至找不到文章出处了，因此搭建一个博客记录自己的工作积累，方便自己查看。</p><h3 id="Markdown-是什么？"><a href="#Markdown-是什么？" class="headerlink" title="Markdown 是什么？"></a>Markdown 是什么？</h3><p>Markdown 是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以 HTML 格式发布。<br>Markdown 也可以理解为将以 MARKDOWN 语法编写的语言转换成 HTML 内容的工具。</p><a id="more"></a><h3 id="为什么使用它？"><a href="#为什么使用它？" class="headerlink" title="为什么使用它？"></a>为什么使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。</li><li>兼容 HTML，可以转换为 HTML 格式发布。<br>跨平台使用。</li><li>越来越多的网站支持 Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li></ul><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>Markdown 语法主要分为如下几大部分： 标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>两种形式：</p><ul><li>1）使用=和-标记一级和二级标题。</li></ul><pre class=" language-bash"><code class="language-bash">一级标题<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>二级标题---------</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><ul><li>2）使用#，可表示 1-6 级标题。<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一级标题</span><span class="token comment" spellcheck="true">## 二级标题</span><span class="token comment" spellcheck="true">### 三级标题</span><span class="token comment" spellcheck="true">#### 四级标题</span><span class="token comment" spellcheck="true">##### 五级标题</span><span class="token comment" spellcheck="true">###### 六级标题</span></code></pre>效果：</li></ul><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。</p><h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 区块引用<span class="token operator">>></span> 嵌套引用</code></pre><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>export default class Page extends Component{<br>render(){<br>return(    </p><p>)<br>}<br>}    </p><p>代码区块：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> default class Page extends Component<span class="token punctuation">{</span>    render<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        return<span class="token punctuation">(</span>            <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>        <span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意:需要和普通段落之间存在空行。</p><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><p>在强调内容两侧分别加上*或者_，如：</p><pre class=" language-bash"><code class="language-bash">*斜体*，_斜体_**粗体**，__粗体__</code></pre><p>效果：</p><p><em>斜体</em>，_斜体_<br><strong>粗体</strong>，<strong>粗体</strong></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>使用·、+、或-标记无序列表，如：</p><pre class=" language-bash"><code class="language-bash">-（+_） 第一项 -（+_） 第二项 - （+\*）第三项</code></pre><p>注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><ul><li>第一项     </li><li>第二项 </li><li>第三项</li></ul><p>有序列表的标记方式是将上述的符号换成数字,并辅以.，如：</p><p>效果：</p><ol><li>第一项     </li><li>第二项 </li><li>第三项</li></ol><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>分割线最常使用就是三个或以上*，还可以使用-和_。</p><pre class=" language-bash"><code class="language-bash">****</code></pre><p>效果：</p><hr><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接可以由两种形式生成：行内式和参考式。\<br>行内式：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>https://juejin.im/timeline<span class="token punctuation">]</span><span class="token punctuation">(</span>https://juejin.im/timeline<span class="token punctuation">)</span></code></pre><p>效果：</p><p><a href="https://juejin.im/timeline" target="_blank" rel="noopener">https://juejin.im/timeline</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个！。</p><pre class=" language-bash"><code class="language-bash">！<span class="token punctuation">[</span>https://juejin.im/timeline<span class="token punctuation">]</span><span class="token punctuation">(</span>https://juejin.im/timeline<span class="token punctuation">)</span></code></pre><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>起到标记作用。如：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>ctrl+a<span class="token variable">`</span></span></code></pre><p>效果：</p><p><code>ctrl+a</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在的前端基本上都用上了前端构建工具，那就难免要写一些readme等等的说明性文件，但是这样的文件一般都是.md的文件,掌握.md文件的书写规则，对提升自己的能力有很大的帮助。此文参考<a href="http://yunxing.fun/2019/04/02/chu-ci-da-jian-bo-ke/" target="_blank" rel="noopener">http://yunxing.fun/2019/04/02/chu-ci-da-jian-bo-ke/</a>)，感谢技术分享。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
